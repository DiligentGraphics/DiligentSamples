#include "structures.fxh"

ConstantBuffer<GlobalConstants> g_Constants;

Texture2D g_GBuffer_Color;
Texture2D g_GBuffer_Normal;
Texture2D g_GBuffer_Depth;
Texture2D g_RayTracedTex;

struct PSInput 
{ 
    float4 Pos : SV_POSITION; 
    float2 UV  : TEX_COORD; 
};

float4 main(in PSInput PSIn) : SV_Target
{
    float2 Dim;
    g_GBuffer_Color.GetDimensions(Dim.x, Dim.y);

    float2 UV       = float2(PSIn.UV.x, 1.0 - PSIn.UV.y);
    int3   TexCoord = int3(UV * Dim, 0);
    float4 Color    = g_GBuffer_Color.Load(TexCoord);
    float3 Normal   = g_GBuffer_Normal.Load(TexCoord).xyz;
    float  Depth    = g_GBuffer_Depth.Load(TexCoord).x;
        
    float4 PosClipSpace;
    PosClipSpace.xy = PSIn.Pos.xy / Dim * float2(2.0, -2.0) + float2(-1.0, 1.0);
    PosClipSpace.z = Depth;
    PosClipSpace.w = 1.0;
    float4 WPos = mul(PosClipSpace, g_Constants.ViewProjInv);
    WPos /= WPos.w;

    float R = 0.0;
    if (Depth < 1.0)
    {
        // Schlick's approximation for Fresnel term
        float3 WPosToCamera = normalize(g_Constants.CameraPos.xyz - WPos.xyz);
        float NdotV = dot(Normal, WPosToCamera);
        float R0 = 0.04;
        R = lerp(R0, 1.0, pow(1 - NdotV, 5.0));
    }

    float4 RTColor  = g_RayTracedTex.Load(TexCoord);

    switch (g_Constants.DrawMode)
    {
        case RENDER_MODE_SHADED:           return lerp(Color * RTColor.a, RTColor, R);
        case RENDER_MODE_G_BUFFER_COLOR:   return Color;
        case RENDER_MODE_G_BUFFER_NORMAL:  return float4(abs(Normal.xyz), 1.0);
        case RENDER_MODE_DIFFUSE_LIGHTING: return Color * RTColor.a;
        case RENDER_MODE_REFLECTIONS:      return RTColor;
        case RENDER_MODE_FRESNEL_TERM:     return float4(R, R, R, 1.0);
    }

    return Color;
}
